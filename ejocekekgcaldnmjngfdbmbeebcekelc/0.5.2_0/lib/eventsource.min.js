// (function(e){"use strict";function t(){this.data={}}function n(){this.listeners=new t}function r(e){setTimeout(function(){throw e},0)}function i(e){this.type=e}function s(e,t){i.call(this,e);this.data=t.data;this.lastEventId=t.lastEventId}function N(e,t){var n=Number(e)||t;return n<x?x:n>T?T:n}function C(e,t,n){try{if(typeof t==="function"){t.call(e,n)}}catch(i){r(i)}}function k(t,r){function z(){H=d;if(M!==null){M.abort();M=null}if(_!==0){clearTimeout(_);_=0}if(D!==0){clearTimeout(D);D=0}L.readyState=d}function W(e){var t=H===p||H===h?M.responseText||"":"";var n=null;if(H===h){var r=0;var o="";if(f){try{r=Number(M.status||0);o=String(M.getResponseHeader("Content-Type")||"")}catch(a){}}else{r=200;o=M.contentType}if(r===200&&w.test(o)){H=p;O=true;A=u;L.readyState=p;n=new i("open");L.dispatchEvent(n);C(L,L.onopen,n);if(H===d){return}}}if(H===p){if(t.length>P){O=true}var l=P-1;var E=t.length;while(++l<E){var S=t[l];if(q===v&&S==="\n"){q=m}else{if(q===v){q=m}if(S==="\r"||S==="\n"){if(R==="data"){B.push(U)}else if(R==="id"){j=U}else if(R==="event"){F=U}else if(R==="retry"){u=N(U,u);A=u}else if(R==="heartbeatTimeout"){x=N(U,x);if(_!==0){clearTimeout(_);_=setTimeout(I,x)}}U="";R="";if(q===m){if(B.length!==0){k=j;if(F===""){F="message"}n=new s(F,{data:B.join("\n"),lastEventId:j});L.dispatchEvent(n);if(F==="message"){C(L,L.onmessage,n)}if(H===d){return}}B.length=0;F=""}q=S==="\r"?v:m}else{if(q===m){q=g}if(q===g){if(S===":"){q=y}else{R+=S}}else if(q===y){if(S!==" "){U+=S}q=b}else if(q===b){U+=S}}}}P=E}if((H===p||H===h)&&(e||P>1024*1024||_===0&&!O)){H=c;M.abort();if(_!==0){clearTimeout(_);_=0}if(A>u*64){A=u*64}if(A>T){A=T}_=setTimeout(I,A);A=A*2+1;L.readyState=h;n=new i("error");L.dispatchEvent(n);C(L,L.onerror,n)}else{if(_===0){O=false;_=setTimeout(I,x)}}}function X(){W(false)}function V(){W(true)}t=String(t);var o=Boolean(a&&r&&r.withCredentials);var u=N(r?r.retry:NaN,1e3);var x=N(r?r.heartbeatTimeout:NaN,45e3);var k=r&&r.lastEventId&&String(r.lastEventId)||"";var L=this;var A=u;var O=false;var M=new l;var _=0;var D=0;var P=0;var H=c;var B=[];var j="";var F="";var I=null;var q=m;var R="";var U="";r=null;if(!S){D=setTimeout(function $(){if(M.readyState===3){X()}D=setTimeout($,500)},0)}I=function(){_=0;if(H!==c){W(false);return}if(navigator.onLine===false){_=setTimeout(I,500);return}if(E&&e.document&&e.document.readyState!=="complete"){_=setTimeout(I,100);return}M.onload=M.onerror=V;M.onabort=V;if(f){M.onreadystatechange=X}if(!S){M.onprogress=X}O=false;_=setTimeout(I,x);P=0;H=h;B.length=0;F="";j=k;U="";R="";q=m;var n=t.slice(0,5);if(n!=="data:"&&n!=="blob:"){n=t+((t.indexOf("?",0)===-1?"?":"&")+"lastEventId="+encodeURIComponent(k)+"&r="+String(Math.random()+1).slice(2))}else{n=t}M.open("GET",n,true);M.withCredentials=o;M.responseType="text";if(f){M.setRequestHeader("Accept","text/event-stream")}M.send(null)};n.call(this);this.close=z;this.url=t;this.readyState=h;this.withCredentials=o;this.onopen=null;this.onmessage=null;this.onerror=null;I()}function L(){this.CONNECTING=h;this.OPEN=p;this.CLOSED=d}t.prototype={get:function(e){return this.data[e+"~"]},set:function(e,t){this.data[e+"~"]=t},"delete":function(e){delete this.data[e+"~"]}};n.prototype={dispatchEvent:function(e){var t=String(e.type);var n=this.listeners;var i=n.get(t);if(!i){return}var s=i.length;var o=-1;var u=null;while(++o<s){u=i[o];try{u.call(this,e)}catch(a){r(a)}}},addEventListener:function(e,t){e=String(e);var n=this.listeners;var r=n.get(e);if(!r){r=[];n.set(e,r)}var i=r.length;while(--i>=0){if(r[i]===t){return}}r.push(t)},removeEventListener:function(e,t){e=String(e);var n=this.listeners;var r=n.get(e);if(!r){return}var i=r.length;var s=[];var o=-1;while(++o<i){if(r[o]!==t){s.push(r[o])}}if(s.length===0){n["delete"](e)}else{n.set(e,s)}}};s.prototype=i.prototype;var o=e.XMLHttpRequest;var u=e.XDomainRequest;var a=Boolean(o&&(new o).withCredentials!==undefined);var f=a;var l=a?o:u;var c=-1;var h=0;var p=1;var d=2;var v=3;var m=4;var g=5;var y=6;var b=7;var w=/^text\/event\-stream;?(\s*charset\=utf\-8)?$/i;var E=/AppleWebKit\/5([0-2][0-9]|3[0-4])[\.\s\w]/.test(navigator.userAgent);var S=Boolean(o&&(new o).sendAsBinary!==undefined);var x=1;var T=18e6;L.prototype=n.prototype;k.prototype=new L;L.call(k);if(l){e.EventSource=k}})(this)
/**
 * eventsource.js
 * Available under MIT License (MIT)
 * https://github.com/Yaffle/EventSource/
 */

/*jslint indent: 2, vars: true, plusplus: true */
/*global setTimeout, clearTimeout */

(function (global) {
  "use strict";

  function Map() {
    this.data = {};
  }

  Map.prototype = {
    get: function (key) {
      return this.data[key + "~"];
    },
    set: function (key, value) {
      this.data[key + "~"] = value;
    },
    "delete": function (key) {
      delete this.data[key + "~"];
    }
  };

  function EventTarget() {
    this.listeners = new Map();
  }

  function throwError(e) {
    setTimeout(function () {
      throw e;
    }, 0);
  }

  EventTarget.prototype = {
    dispatchEvent: function (event) {
      event.target = this;
      var type = String(event.type);
      var listeners = this.listeners;
      var typeListeners = listeners.get(type);
      if (!typeListeners) {
        return;
      }
      var length = typeListeners.length;
      var i = -1;
      var listener = null;
      while (++i < length) {
        listener = typeListeners[i];
        try {
          listener.call(this, event);
        } catch (e) {
          throwError(e);
        }
      }
    },
    addEventListener: function (type, callback) {
      type = String(type);
      var listeners = this.listeners;
      var typeListeners = listeners.get(type);
      if (!typeListeners) {
        typeListeners = [];
        listeners.set(type, typeListeners);
      }
      var i = typeListeners.length;
      while (--i >= 0) {
        if (typeListeners[i] === callback) {
          return;
        }
      }
      typeListeners.push(callback);
    },
    removeEventListener: function (type, callback) {
      type = String(type);
      var listeners = this.listeners;
      var typeListeners = listeners.get(type);
      if (!typeListeners) {
        return;
      }
      var length = typeListeners.length;
      var filtered = [];
      var i = -1;
      while (++i < length) {
        if (typeListeners[i] !== callback) {
          filtered.push(typeListeners[i]);
        }
      }
      if (filtered.length === 0) {
        listeners["delete"](type);
      } else {
        listeners.set(type, filtered);
      }
    }
  };

  function Event(type) {
    this.type = type;
    this.target = null;
  }

  function MessageEvent(type, options) {
    Event.call(this, type);
    this.data = options.data;
    this.lastEventId = options.lastEventId;
  }

  MessageEvent.prototype = Event.prototype;

  var XHR = global.XMLHttpRequest;
  var XDR = global.XDomainRequest;
  var isCORSSupported = Boolean(XHR && ((new XHR()).withCredentials !== undefined));
  var isXHR = isCORSSupported;
  var Transport = isCORSSupported ? XHR : XDR;
  var WAITING = -1;
  var CONNECTING = 0;
  var OPEN = 1;
  var CLOSED = 2;
  var AFTER_CR = 3;
  var FIELD_START = 4;
  var FIELD = 5;
  var VALUE_START = 6;
  var VALUE = 7;
  var contentTypeRegExp = /^text\/event\-stream;?(\s*charset\=utf\-8)?$/i;

  var MINIMUM_DURATION = 1000;
  var MAXIMUM_DURATION = 18000000;

  function getDuration(value, def) {
    var n = Number(value) || def;
    return (n < MINIMUM_DURATION ? MINIMUM_DURATION : (n > MAXIMUM_DURATION ? MAXIMUM_DURATION : n));
  }

  function fire(that, f, event) {
    try {
      if (typeof f === "function") {
        f.call(that, event);
      }
    } catch (e) {
      throwError(e);
    }
  }

  function EventSource(url, options) {
    url = String(url);

    var withCredentials = Boolean(isCORSSupported && options && options.withCredentials);
    var initialRetry = getDuration(options ? options.retry : NaN, 1000);
    var heartbeatTimeout = getDuration(options ? options.heartbeatTimeout : NaN, 45000);
    var lastEventId = (options && options.lastEventId && String(options.lastEventId)) || "";
    var that = this;
    var retry = initialRetry;
    var wasActivity = false;
    var xhr = new Transport();
    var timeout = 0;
    var timeout0 = 0;
    var charOffset = 0;
    var currentState = WAITING;
    var dataBuffer = [];
    var lastEventIdBuffer = "";
    var eventTypeBuffer = "";
    var onTimeout = null;

    var state = FIELD_START;
    var field = "";
    var value = "";

    options = null;

    function close() {
      currentState = CLOSED;
      if (xhr !== null) {
        xhr.abort();
        xhr = null;
      }
      if (timeout !== 0) {
        clearTimeout(timeout);
        timeout = 0;
      }
      if (timeout0 !== 0) {
        clearTimeout(timeout0);
        timeout0 = 0;
      }
      that.readyState = CLOSED;
    }

    function onProgress(isLoadEnd) {
      var responseText = currentState === OPEN || currentState === CONNECTING ? xhr.responseText || "" : "";
      var event = null;
      var isWrongStatusCodeOrContentType = false;

      if (currentState === CONNECTING) {
        var status = 0;
        var statusText = "";
        var contentType = "";
        if (isXHR) {
          try {
            status = Number(xhr.status || 0);
            statusText = String(xhr.statusText || "");
            contentType = String(xhr.getResponseHeader("Content-Type") || "");
          } catch (error) {
            // https://bugs.webkit.org/show_bug.cgi?id=29121
            status = 0;
            // FF < 14, WebKit
            // https://bugs.webkit.org/show_bug.cgi?id=29658
            // https://bugs.webkit.org/show_bug.cgi?id=77854
          }
        } else {
          status = 200;
          contentType = xhr.contentType;
        }
        if (status === 200 && contentTypeRegExp.test(contentType)) {
          currentState = OPEN;
          wasActivity = true;
          retry = initialRetry;
          that.readyState = OPEN;
          event = new Event("open");
          that.dispatchEvent(event);
          fire(that, that.onopen, event);
          if (currentState === CLOSED) {
            return;
          }
        } else {
          if (status !== 0) {
            var message = "";
            if (status !== 200) {
              message = "EventSource's response has a status " + status + " " + statusText.replace(/\s+/g, " ") + " that is not 200. Aborting the connection.";
            } else {
              message = "EventSource's response has a Content-Type specifying an unsupported type: " + contentType.replace(/\s+/g, " ") + ". Aborting the connection.";
            }
            setTimeout(function () {
              throw new Error(message);
            });
            isWrongStatusCodeOrContentType = true;
          }
        }
      }

      if (currentState === OPEN) {
        if (responseText.length > charOffset) {
          wasActivity = true;
        }
        var i = charOffset - 1;
        var length = responseText.length;
        var c = "\n";
        while (++i < length) {
          c = responseText[i];
          if (state === AFTER_CR && c === "\n") {
            state = FIELD_START;
          } else {
            if (state === AFTER_CR) {
              state = FIELD_START;
            }
            if (c === "\r" || c === "\n") {
              if (field === "data") {
                dataBuffer.push(value);
              } else if (field === "id") {
                lastEventIdBuffer = value;
              } else if (field === "event") {
                eventTypeBuffer = value;
              } else if (field === "retry") {
                initialRetry = getDuration(value, initialRetry);
                retry = initialRetry;
              } else if (field === "heartbeatTimeout") {//!
                heartbeatTimeout = getDuration(value, heartbeatTimeout);
                if (timeout !== 0) {
                  clearTimeout(timeout);
                  timeout = setTimeout(onTimeout, heartbeatTimeout);
                }
              }
              value = "";
              field = "";
              if (state === FIELD_START) {
                if (dataBuffer.length !== 0) {
                  lastEventId = lastEventIdBuffer;
                  if (eventTypeBuffer === "") {
                    eventTypeBuffer = "message";
                  }
                  event = new MessageEvent(eventTypeBuffer, {
                    data: dataBuffer.join("\n"),
                    lastEventId: lastEventIdBuffer
                  });
                  that.dispatchEvent(event);
                  if (eventTypeBuffer === "message") {
                    fire(that, that.onmessage, event);
                  }
                  if (currentState === CLOSED) {
                    return;
                  }
                }
                dataBuffer.length = 0;
                eventTypeBuffer = "";
              }
              state = c === "\r" ? AFTER_CR : FIELD_START;
            } else {
              if (state === FIELD_START) {
                state = FIELD;
              }
              if (state === FIELD) {
                if (c === ":") {
                  state = VALUE_START;
                } else {
                  field += c;
                }
              } else if (state === VALUE_START) {
                if (c !== " ") {
                  value += c;
                }
                state = VALUE;
              } else if (state === VALUE) {
                value += c;
              }
            }
          }
        }
        charOffset = length;
      }

      if ((currentState === OPEN || currentState === CONNECTING) &&
          (isLoadEnd || isWrongStatusCodeOrContentType || (charOffset > 1024 * 1024) || (timeout === 0 && !wasActivity))) {
        currentState = WAITING;
        xhr.abort();
        if (timeout !== 0) {
          clearTimeout(timeout);
          timeout = 0;
        }
        if (retry > initialRetry * 16) {
          retry = initialRetry * 16;
        }
        if (retry > MAXIMUM_DURATION) {
          retry = MAXIMUM_DURATION;
        }
        timeout = setTimeout(onTimeout, retry);
        retry = retry * 2 + 1;

        that.readyState = CONNECTING;
        event = new Event("error");
        that.dispatchEvent(event);
        fire(that, that.onerror, event);
      } else {
        if (timeout === 0) {
          wasActivity = false;
          timeout = setTimeout(onTimeout, heartbeatTimeout);
        }
      }
    }

    function onProgress2() {
      onProgress(false);
    }

    function onLoadEnd() {
      onProgress(true);
    }

    /* 140311 SAGIBB: This is a fix for opera that causes hight CPU usage */
    // if (isXHR) {
    //   // workaround for Opera issue with "progress" events
    //   timeout0 = setTimeout(function f() {
    //     if (xhr.readyState === 3) {
    //       onProgress2();
    //     }
    //     timeout0 = setTimeout(f, 500);
    //   }, 0);
    // }

    onTimeout = function () {
      timeout = 0;
      if (currentState !== WAITING) {
        onProgress(false);
        return;
      }
      // loading indicator in Safari, Chrome < 14, Firefox
      // https://bugzilla.mozilla.org/show_bug.cgi?id=736723
      if (isXHR && (xhr.sendAsBinary !== undefined || xhr.onloadend === undefined) && global.document && global.document.readyState && global.document.readyState !== "complete") {
        timeout = setTimeout(onTimeout, 4);
        return;
      }
      // XDomainRequest#abort removes onprogress, onerror, onload

      xhr.onload = xhr.onerror = onLoadEnd;

      if (isXHR) {
        // improper fix to match Firefox behaviour, but it is better than just ignore abort
        // see https://bugzilla.mozilla.org/show_bug.cgi?id=768596
        // https://bugzilla.mozilla.org/show_bug.cgi?id=880200
        // https://code.google.com/p/chromium/issues/detail?id=153570
        xhr.onabort = onLoadEnd;

        // Firefox 3.5 - 3.6 - ? < 9.0
        // onprogress is not fired sometimes or delayed
        xhr.onreadystatechange = onProgress2;
      }

      xhr.onprogress = onProgress2;

      wasActivity = false;
      timeout = setTimeout(onTimeout, heartbeatTimeout);

      charOffset = 0;
      currentState = CONNECTING;
      dataBuffer.length = 0;
      eventTypeBuffer = "";
      lastEventIdBuffer = lastEventId;
      value = "";
      field = "";
      state = FIELD_START;

      var s = url.slice(0, 5);
      if (s !== "data:" && s !== "blob:") {
        s = url + ((url.indexOf("?", 0) === -1 ? "?" : "&") + "lastEventId=" + encodeURIComponent(lastEventId) + "&r=" + String(Math.random() + 1).slice(2));
      } else {
        s = url;
      }
      xhr.open("GET", s, true);

      if (isXHR) {
        // withCredentials should be set after "open" for Safari and Chrome (< 19 ?)
        xhr.withCredentials = withCredentials;

        xhr.responseType = "text";

        // Request header field Cache-Control is not allowed by Access-Control-Allow-Headers.
        // "Cache-control: no-cache" are not honored in Chrome and Firefox
        // https://bugzilla.mozilla.org/show_bug.cgi?id=428916
        //xhr.setRequestHeader("Cache-Control", "no-cache");
        xhr.setRequestHeader("Accept", "text/event-stream");
        // Request header field Last-Event-ID is not allowed by Access-Control-Allow-Headers.
        //xhr.setRequestHeader("Last-Event-ID", lastEventId);
      }

      xhr.send(null);
    };

    EventTarget.call(this);
    this.close = close;
    this.url = url;
    this.readyState = CONNECTING;
    this.withCredentials = withCredentials;

    this.onopen = null;
    this.onmessage = null;
    this.onerror = null;

    onTimeout();
  }

  function F() {
    this.CONNECTING = CONNECTING;
    this.OPEN = OPEN;
    this.CLOSED = CLOSED;
  }
  F.prototype = EventTarget.prototype;

  EventSource.prototype = new F();
  F.call(EventSource);

  if (Transport) {
    // Why replace a native EventSource ?
    // https://bugzilla.mozilla.org/show_bug.cgi?id=444328
    // https://bugzilla.mozilla.org/show_bug.cgi?id=831392
    // https://code.google.com/p/chromium/issues/detail?id=260144
    // https://code.google.com/p/chromium/issues/detail?id=225654
    // ...
    global.NativeEventSource = global.EventSource;
    global.EventSource = EventSource;
  }

}(this));